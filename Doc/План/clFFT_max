Цель работы:
  Создать класс используя  OpenCLComputeEngine который реализовывал следующую забачу
  - получал на вход вектор комплексных чисел и описание 
    - beam_count - количество лучей
    - count_points - количество точек в луче
    - out_count_points_fft - количество точек в FFT
  - на выходе 
    в тестовом режиме выводить struct FFTResult {
       - вектор структуры {index_point, Amplitude, Phase} - таких 3 (5) максимальных значения 
    }
    Если смотреть вывод в разрезе всех лучей то должно получиться: 
      vector<FFTResult> v_fft_result плучим вектор структур к каждому лучу(beam_count)

    в рабочем варианте у нас будет входной вектор состоящий из вектора структуры в которос помещены {index_point, Amplitude, Phase} 3 значения
    vector<vector<struct {index_point, Amplitude, Phase}>> v_input_data;
    
Алгоритм работы: все выполняем на GPU с использованием kernel'ов
  1. в модуль получаем входной вектор состоящий из компрексных чисел с описанием beam_count, count_points, out_count_points_fft 
    1.2 проверяем count_points на кратность 2^n если не кратно то дополняем до ближайшего большего числа кратного 2^n пулями.
    1.3 полученное значение величиваем в 2 раза и получаем nFFT. 
    1.4 полученое значение nFFT умножаем на beam_count и создаем буфер для входного/входного вектора комплексных чисел.
        у нас должно получиться в идеале 
        RAM GPU [nFFT0, nFFT1, nFFT(beam_count-1)] 
        данные в нутри каждого буфера nFFT0[0..nFFT-1 (вектор комплексных чисел входные данные), остальные нули (паддинг)]
    1.5 записываем  на GPU входной вектор комплексных чисел. целеком вектор в один буфер.
    1.6 работа 1 kernel'а он должен перенести данные из входного буфера в начало блока памяти каждого блока nFFT(beam)
        данные нужно переносить с последнего beam в соответствующее место 
        пример: beam_count = 3, count_points = 100, nFFT = 256 переносим 
        из beam_count = 3 * count_points = 300 этой ячейки в  beam_count = 3* nFFT = 256 в 3*256 = 768 эту ячейки 100 точек
        там гед  были данные должны бытьнули! и так для каждого beam.
        так мы подготовим данные для FFT.
    1.7 Берем FFT библиотекой clFFT.
    1.9 Считаем магнитуду (огибающую), и фазы, получаем 3 максимальных значений. и записываем в выходной буфер 
        вектор структуры {index_point, Amplitude, Phase}. и выводим.
    1.10 Вся работа Профилируется средствами OpenCl на GPU
    1.11 Выводим результат в консоль и в файл каталога @/Reports в форма md
  Обрати внимание мы реализуем п. 1.7 с двумя callback как это делалось в        
в этом рабочем проекте   E:\C++\Cuda\OpenCLProd\LOpenCl 
E:\C++\Cuda\OpenCLProd\LOpenCl\src\Native3Dcustom.cpp - пример вызыва 2 callback
callback 1 вызывает kernel 1.6 перед запуском FFT
callback 2 вызывает kernel 1.8 после запуском FFT

Входные данные создай используя генератор GeneratorGPU::signal_sinusoids
используй пример из test_signal_sinusoids.hpp
 test_empty_map()- без map
 заложи 5 лучей и 1000 точек в луч

Используй sequential-thinking (MCP server).
Шаг за шагом:
1. Прочитай все файлы
2. Поймй архитектуру
3. ПОТОМ пиши код
если не понятно спроси

