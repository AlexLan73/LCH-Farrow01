# AntennaFFTProcMax Architecture

## Обзор

`AntennaFFTProcMax` - высокопроизводительный класс для FFT обработки сигналов с поиском максимальных амплитуд на каждой антенне. Использует clFFT с callback'ами для максимальной производительности.

## Архитектура

### Компоненты

1. **OpenCLComputeEngine** - главный фасад для работы с OpenCL
2. **clFFT** - библиотека для выполнения FFT на GPU
3. **Callback функции** - pre и post обработка данных
4. **Reduction kernel** - поиск максимумов на GPU

### Поток данных

```
Входной сигнал (GPU)
    ↓
Pre-callback: Перенос данных + padding
    ↓
clFFT: Выполнение FFT
    ↓
Post-callback: fftshift + magnitude/phase
    ↓
Reduction kernel: Поиск топ-N максимумов
    ↓
Результаты (CPU/GPU)
```

## Структуры данных

### AntennaFFTParams
- `beam_count` - количество лучей/антенн
- `count_points` - количество точек в луче
- `out_count_points_fft` - количество точек в FFT для вывода
- `max_peaks_count` - количество максимальных значений (3-5)
- `task_id`, `module_name` - признаки задачи

### AntennaFFTResult
- `results` - вектор результатов для каждого луча
- `total_beams`, `nFFT` - метаданные
- `task_id`, `module_name` - признаки задачи

## Алгоритм работы

### 1. Вычисление nFFT
- Проверка кратности 2^n
- Дополнение до ближайшего большего числа кратного 2^n
- Умножение на 2

### 2. Pre-callback
- Перенос данных из входного буфера в блоки nFFT
- Дополнение нулями (padding)

### 3. FFT
- Выполнение через clFFT
- Batch обработка для всех лучей

### 4. Post-callback
- fftshift для двух диапазонов:
  - Диапазон 1: от [(nFFT-1)-out_count_points_fft/2] до (nFFT-1)
  - Диапазон 2: от 0 до out_count_points_fft/2
- Вычисление magnitude и phase

### 5. Поиск максимумов
- Выполняется ТОЛЬКО на GPU
- Использует reduction kernel
- Находит топ-N максимумов для каждого луча

## Оптимизации

1. **Кэширование планов FFT** - переиспользование при одинаковых параметрах
2. **Persistent буферы** - не пересоздаются при каждом вызове
3. **Асинхронные операции** - где возможно
4. **Минимизация копирований** - данные остаются на GPU
5. **Оптимизированные callback'ы** - минимум операций

## Профилирование

Детальное профилирование всех операций:
- Загрузка данных
- Pre-callback
- FFT
- Post-callback
- Reduction
- Чтение результатов

## Масштабируемость

Класс разработан для использования множества экземпляров:
- Признаки задачи (task_id, module_name) в структурах
- Кэш планов FFT (статический, общий для всех экземпляров)
- Thread-safe доступ к ресурсам

