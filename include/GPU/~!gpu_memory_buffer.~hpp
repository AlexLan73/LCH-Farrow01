// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GPUMemoryBuffer - RAII ĞºĞ»Ğ°ÑÑ Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ GPU Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒÑ CPU â†” GPU
// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ pinned memory Ğ´Ğ»Ñ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ DMA Ñ‚Ñ€Ğ°Ğ½ÑÑ„ĞµÑ€Ğ°
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#pragma once

#include <memory>
#include <vector>
#include <complex>
#include <stdexcept>
#include <iostream>
#include <CL/cl.h>
#include <cstring>

#include <CL/cl.h>
#include <vector>
#include <complex>
#include <memory>
#include <iostream>
#include <cstring>
#include <stdexcept>

namespace gpu{
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Enum Ğ´Ğ»Ñ Ñ‚Ğ¸Ğ¿Ğ¾Ğ² Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

enum class MemoryType {
    GPU_WRITE_ONLY,      // Kernel Ğ¿Ğ¸ÑˆĞµÑ‚, CPU Ñ‡Ğ¸Ñ‚Ğ°ĞµÑ‚
    GPU_READ_ONLY,       // CPU Ğ¿Ğ¸ÑˆĞµÑ‚, kernel Ñ‡Ğ¸Ñ‚Ğ°ĞµÑ‚
    GPU_READ_WRITE,      // ĞĞ±Ğ° Ñ‡Ğ¸Ñ‚Ğ°ÑÑ‚ Ğ¸ Ğ¿Ğ¸ÑˆÑƒÑ‚
    PINNED_HOST,         // Pinned memory Ğ½Ğ° Ñ…Ğ¾ÑÑ‚Ğµ (Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ DMA Ñ‚Ñ€Ğ°Ğ½ÑÑ„ĞµÑ€)
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GPUMemoryBuffer - Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ ĞºĞ»Ğ°ÑÑ Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒÑ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class GPUMemoryBuffer {
public:
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ĞšĞĞĞ¡Ğ¢Ğ Ğ£ĞšĞ¢ĞĞ  - Ğ²Ñ‹Ğ´ĞµĞ»ÑĞµÑ‚ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ GPU + pinned memory Ğ½Ğ° Ñ…Ğ¾ÑÑ‚Ğµ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    GPUMemoryBuffer(
        cl_context context,
        cl_command_queue queue,
        cl_mem signal_gpu,        
        size_t num_elements,
        MemoryType type = MemoryType::GPU_WRITE_ONLY
    ) : context_(context),
        queue_(queue),
        num_elements_(num_elements),
        element_size_(sizeof(std::complex<float>)),
        memory_type_(type),
        gpu_buffer_(signal_gpu),
        cpu_buffer_(nullptr),
        cpu_pinned_buffer_(nullptr),
        is_gpu_dirty_(false)
    {
        if (!context || !queue) {
            throw std::invalid_argument("Invalid OpenCL context or queue");
        }
        if (num_elements == 0) {
            throw std::invalid_argument("Number of elements must be > 0");
        }

        // Ğ’Ñ‹Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ GPU Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ
        AllocateGPUBuffer();
        
        // Ğ’Ñ‹Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ CPU pinned Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ Ğ´Ğ»Ñ DMA Ñ‚Ñ€Ğ°Ğ½ÑÑ„ĞµÑ€Ğ°
        AllocatePinnedHostBuffer();
        
        std::cout << "âœ… GPUMemoryBuffer created: " 
                  << (GetTotalBytes() / (1024.0 * 1024.0)) << " MB (GPU + Pinned Host)\n";
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Ğ”Ğ•Ğ¡Ğ¢Ğ Ğ£ĞšĞ¢ĞĞ  - Ğ¾ÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´Ğ°ĞµÑ‚ GPU + HOST Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ (RAII)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    ~GPUMemoryBuffer() noexcept {
        try {
            ReleaseGPUBuffer();
            ReleasePinnedHostBuffer();
        } catch (const std::exception& e) {
            std::cerr << "âš ï¸  Exception in ~GPUMemoryBuffer: " << e.what() << "\n";
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Ğ—Ğ°Ğ¿Ñ€ĞµÑ‚Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    GPUMemoryBuffer(const GPUMemoryBuffer&) = delete;
    GPUMemoryBuffer& operator=(const GPUMemoryBuffer&) = delete;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Ğ Ğ°Ğ·Ñ€ĞµÑˆĞ¸Ñ‚ÑŒ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰ĞµĞ½Ğ¸Ğµ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    GPUMemoryBuffer(GPUMemoryBuffer&& other) noexcept
        : context_(other.context_),
          queue_(other.queue_),
          num_elements_(other.num_elements_),
          element_size_(other.element_size_),
          memory_type_(other.memory_type_),
          gpu_buffer_(other.gpu_buffer_),
          cpu_buffer_(other.cpu_buffer_),
          cpu_pinned_buffer_(other.cpu_pinned_buffer_),
          is_gpu_dirty_(other.is_gpu_dirty_)
    {
        other.gpu_buffer_ = nullptr;
        other.cpu_buffer_ = nullptr;
        other.cpu_pinned_buffer_ = nullptr;
    }

    GPUMemoryBuffer& operator=(GPUMemoryBuffer&& other) noexcept {
        if (this != &other) {
            ReleaseGPUBuffer();
            ReleasePinnedHostBuffer();

            context_ = other.context_;
            queue_ = other.queue_;
            num_elements_ = other.num_elements_;
            element_size_ = other.element_size_;
            memory_type_ = other.memory_type_;
            gpu_buffer_ = other.gpu_buffer_;
            cpu_buffer_ = other.cpu_buffer_;
            cpu_pinned_buffer_ = other.cpu_pinned_buffer_;
            is_gpu_dirty_ = other.is_gpu_dirty_;

            other.gpu_buffer_ = nullptr;
            other.cpu_buffer_ = nullptr;
            other.cpu_pinned_buffer_ = nullptr;
        }
        return *this;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PUBLIC API: Ğ¢Ñ€Ğ°Ğ½ÑÑ„ĞµÑ€ GPU â†’ CPU (Ñ pinned memory Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸ĞµĞ¹)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    std::vector<std::complex<float>> ReadFromGPU() {
        if (!gpu_buffer_) {
            throw std::runtime_error("GPU buffer not allocated");
        }

        std::cout << "ğŸ“¥ Transferring data GPU â†’ CPU (" 
                  << (GetTotalBytes() / (1024.0 * 1024.0)) << " MB)...\n";

        // Ğ¨Ğ°Ğ³ 1: GPU â†’ Pinned Host Memory (Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ DMA)
        cl_int err = clEnqueueReadBuffer(
            queue_,
            gpu_buffer_,
            CL_TRUE,  // Blocking read
            0,
            GetTotalBytes(),
            cpu_pinned_buffer_.get(),
            0, nullptr, nullptr
        );

        if (err != CL_SUCCESS) {
            throw std::runtime_error(
                "Failed to read from GPU buffer (err: " + std::to_string(err) + ")"
            );
        }

        // Ğ”Ğ¾Ğ¶Ğ´Ğ°Ñ‚ÑŒÑÑ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ Ğ²ÑĞµÑ… Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹ Ğ½Ğ° GPU
        clFinish(queue_);

        // Ğ¨Ğ°Ğ³ 2: Pinned Host Memory â†’ CPU Vector (Ğ¾Ñ‡ĞµĞ½ÑŒ Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾, Ñ‚.Ğº. pinned)
        std::vector<std::complex<float>> result(num_elements_);
        std::memcpy(
            result.data(),
            cpu_pinned_buffer_.get(),
            GetTotalBytes()
        );

        is_gpu_dirty_ = false;
        std::cout << "âœ… Data transfer GPU â†’ CPU complete\n";
        return result;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PUBLIC API: Ğ¢Ñ€Ğ°Ğ½ÑÑ„ĞµÑ€ CPU â†’ GPU (Ñ pinned memory Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸ĞµĞ¹)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    void WriteToGPU(const std::vector<std::complex<float>>& data) {
        if (!gpu_buffer_) {
            throw std::runtime_error("GPU buffer not allocated");
        }

        if (data.size() != num_elements_) {
            throw std::invalid_argument(
                "Data size mismatch: expected " + std::to_string(num_elements_) +
                ", got " + std::to_string(data.size())
            );
        }

        std::cout << "ğŸ“¤ Transferring data CPU â†’ GPU (" 
                  << (GetTotalBytes() / (1024.0 * 1024.0)) << " MB)...\n";

        // Ğ¨Ğ°Ğ³ 1: CPU Vector â†’ Pinned Host Memory (Ğ¾Ñ‡ĞµĞ½ÑŒ Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾)
        std::memcpy(
            cpu_pinned_buffer_.get(),
            data.data(),
            GetTotalBytes()
        );

        // Ğ¨Ğ°Ğ³ 2: Pinned Host Memory â†’ GPU (Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ DMA)
        cl_int err = clEnqueueWriteBuffer(
            queue_,
            gpu_buffer_,
            CL_TRUE,  // Blocking write
            0,
            GetTotalBytes(),
            cpu_pinned_buffer_.get(),
            0, nullptr, nullptr
        );

        if (err != CL_SUCCESS) {
            throw std::runtime_error(
                "Failed to write to GPU buffer (err: " + std::to_string(err) + ")"
            );
        }

        // Ğ”Ğ¾Ğ¶Ğ´Ğ°Ñ‚ÑŒÑÑ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ Ğ²ÑĞµÑ… Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹ Ğ½Ğ° GPU
        clFinish(queue_);

        is_gpu_dirty_ = true;
        std::cout << "âœ… Data transfer CPU â†’ GPU complete\n";
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PUBLIC API: Ğ§Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ğ¾Ğµ Ñ‡Ñ‚ĞµĞ½Ğ¸Ğµ (Ğ¿ĞµÑ€Ğ²Ñ‹Ğµ N ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    std::vector<std::complex<float>> ReadPartial(size_t num_samples) {
        if (num_samples > num_elements_) {
            num_samples = num_elements_;
        }

        if (!gpu_buffer_) {
            throw std::runtime_error("GPU buffer not allocated");
        }

        std::cout << "ğŸ“¥ Partial read GPU â†’ CPU (" << num_samples << " samples)...\n";

        // Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ½ÑƒĞ¶Ğ½Ğ¾Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²
        size_t bytes_to_read = num_samples * element_size_;

        cl_int err = clEnqueueReadBuffer(
            queue_,
            gpu_buffer_,
            CL_TRUE,
            0,
            bytes_to_read,
            cpu_pinned_buffer_.get(),
            0, nullptr, nullptr
        );

        if (err != CL_SUCCESS) {
            throw std::runtime_error(
                "Failed to read from GPU buffer (err: " + std::to_string(err) + ")"
            );
        }

        clFinish(queue_);

        std::vector<std::complex<float>> result(num_samples);
        std::memcpy(
            result.data(),
            cpu_pinned_buffer_.get(),
            bytes_to_read
        );

        std::cout << "âœ… Partial read complete\n";
        return result;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PUBLIC API: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ GPU Ğ±ÑƒÑ„ĞµÑ€ Ğ´Ğ»Ñ kernel
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    cl_mem GetGPUBuffer() const {
        return gpu_buffer_;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PUBLIC API: ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ CPU pinned Ğ±ÑƒÑ„ĞµÑ€
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    std::complex<float>* GetPinnedHostBuffer() {
        return cpu_pinned_buffer_.get();
    }

    const std::complex<float>* GetPinnedHostBuffer() const {
        return cpu_pinned_buffer_.get();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PUBLIC API: Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    size_t GetNumElements() const { return num_elements_; }
    size_t GetElementSize() const { return element_size_; }
    size_t GetTotalBytes() const { return num_elements_ * element_size_; }
    bool IsGPUDirty() const { return is_gpu_dirty_; }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PUBLIC API: Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    void PrintStats() const {
        std::cout << "\nğŸ“Š GPUMemoryBuffer Statistics:\n"
                  << "  Elements: " << num_elements_ << "\n"
                  << "  Total Size: " << (GetTotalBytes() / (1024.0 * 1024.0)) << " MB\n"
                  << "  GPU Dirty: " << (is_gpu_dirty_ ? "Yes" : "No") << "\n"
                  << "  Memory Type: " << MemoryTypeToString() << "\n\n";
    }

private:
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PRIVATE: Ğ’Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ GPU Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    void AllocateGPUBuffer() {
        cl_int err = CL_SUCCESS;
        size_t size = GetTotalBytes();

        cl_mem_flags flags = CL_MEM_READ_WRITE;
        switch (memory_type_) {
            case MemoryType::GPU_WRITE_ONLY:
                flags = CL_MEM_WRITE_ONLY;
                break;
            case MemoryType::GPU_READ_ONLY:
                flags = CL_MEM_READ_ONLY;
                break;
            default:
                flags = CL_MEM_READ_WRITE;
        }

        gpu_buffer_ = clCreateBuffer(context_, flags, size, nullptr, &err);

        if (err != CL_SUCCESS) {
            throw std::runtime_error(
                "Failed to allocate GPU buffer (err: " + std::to_string(err) + ")"
            );
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PRIVATE: Ğ’Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ pinned host Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    void AllocatePinnedHostBuffer() {
        cl_int err = CL_SUCCESS;
        size_t size = GetTotalBytes();

        // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ pinned memory buffer Ğ´Ğ»Ñ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ DMA Ñ‚Ñ€Ğ°Ğ½ÑÑ„ĞµÑ€Ğ°
        cl_mem pinned_mem = clCreateBuffer(
            context_,
            CL_MEM_ALLOC_HOST_PTR,
            size,
            nullptr,
            &err
        );

        if (err != CL_SUCCESS) {
            throw std::runtime_error(
                "Failed to allocate pinned host buffer (err: " + std::to_string(err) + ")"
            );
        }

        // ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ·Ğ¸Ñ‚ÑŒ pinned memory Ğ² Ğ°Ğ´Ñ€ĞµÑĞ½Ğ¾Ğµ Ğ¿Ñ€Ğ¾ÑÑ‚Ñ€Ğ°Ğ½ÑÑ‚Ğ²Ğ¾ CPU
        void* host_ptr = clEnqueueMapBuffer(
            queue_,
            pinned_mem,
            CL_TRUE,
            CL_MAP_READ | CL_MAP_WRITE,
            0,
            size,
            0, nullptr, nullptr,
            &err
        );

        if (err != CL_SUCCESS) {
            clReleaseMemObject(pinned_mem);
            throw std::runtime_error(
                "Failed to map pinned host buffer (err: " + std::to_string(err) + ")"
            );
        }

        // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ
        cpu_pinned_buffer_ = std::shared_ptr<std::complex<float>>(
            static_cast<std::complex<float>*>(host_ptr),
            [this, pinned_mem](std::complex<float>*) {
                clEnqueueUnmapMemObject(queue_, pinned_mem, 
                    static_cast<void*>(cpu_pinned_buffer_.get()), 
                    0, nullptr, nullptr);
                clReleaseMemObject(pinned_mem);
            }
        );
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PRIVATE: ĞÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ GPU Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    void ReleaseGPUBuffer() {
        if (gpu_buffer_) {
            clReleaseMemObject(gpu_buffer_);
            gpu_buffer_ = nullptr;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PRIVATE: ĞÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ pinned host Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    void ReleasePinnedHostBuffer() {
        if (cpu_pinned_buffer_) {
            cpu_pinned_buffer_.reset();
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PRIVATE: Ğ£Ñ‚Ğ¸Ğ»Ğ¸Ñ‚Ñ‹
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    std::string MemoryTypeToString() const {
        switch (memory_type_) {
            case MemoryType::GPU_WRITE_ONLY: return "GPU_WRITE_ONLY";
            case MemoryType::GPU_READ_ONLY: return "GPU_READ_ONLY";
            case MemoryType::GPU_READ_WRITE: return "GPU_READ_WRITE";
            case MemoryType::PINNED_HOST: return "PINNED_HOST";
            default: return "UNKNOWN";
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MEMBERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    cl_context context_;
    cl_command_queue queue_;
    size_t num_elements_;
    size_t element_size_;
    MemoryType memory_type_;
    
    cl_mem gpu_buffer_;
    std::vector<std::complex<float>>* cpu_buffer_;
    std::shared_ptr<std::complex<float>> cpu_pinned_buffer_;
    
    bool is_gpu_dirty_;
};

}// namespace gpu

